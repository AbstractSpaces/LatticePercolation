Structures:

	partition
	{
		eastX			// x coordinate of eastern border.
		westX			// Same for western border.
		sub[]			// Array of subclusters found inside partition.
		eastY[]			// Each element relates to a y coordinate on eastern border.
						// If a subcluster touches the border, its index in
						// found is set as the value for the eastY it touches.
		westY[]			// Same for western border.
	}

	subcluster
	{
		size 			// No. sites in subcluster.
		minY			// The coordinate of the northernmost point.
		maxY			// Coordinate of southernmost point. If the subcluster
						// wraps around, this value is still incremented rather
						// than wrapped.
		minX
		maxX			
	}
	
	cluster
	{
		size
		sub[][]			// Identifying values for each subcluster in the cluster.
		minY
		maxY
		minX
		maxX
	}

Process:

	Threads/nodes perform local DFS on subclusters in their partition.
	Send their data back to master.
	
	After all partitions searched, master stitches together touching subclusters.
	Iterating left to right, master runs down the eastY and westY of each border.
	If both arrays have subclusters in the same coordinate, the two subclusters
	are stitched together if they aren't already part of the same cluster.
		If both subclusters already belong to different clusters, merge the two
		clusters.
		If already belongs to a cluster, add the other subcluster to that cluster.
		Otherwise create a new cluster from the two subclusters.
	After processing subclusters that touch the border, add any unprocessed subclusters
	as new clusters.
	
	In theory, each subcluster should be processed once and end up as part of a new
	or existing cluster.

Notes:

	Each partition's subclusters will be indexed from 0, need a way to translate from partition local identifiers to global identifiers.
		Simplest way is to use a tuple, with identifier for partition and subcluster.
		Either an array or bit twiddling will work.
		
	Arrays of subclusters and clusters will need to be dynamically sizeable.
	
	Partition and master stitcher will need a live record of the highest identifier in use.
	
	Merging span data will simply take the larger of the two values.
	
	Recording spans as eastmost coord, westmost etc. will give erroneous results for clusters that wrap around but don't meet in middle.
		Record north and westmost coord without wraparound, and south and eastmost coord but continuing to increment them if the cluster wraps around (rather than modulo them). Hence south-north and east-west gives the distance of the span.
		
	How to identify whether a subcluster belongs to a given cluster?
		A searchable collection sounds messy and difficult to do in C.
		A boolean array with an element for each subcluster could work, just need to translate subclusters into indices.
			Could be a 2d matrix, x values relating to partition number and y values relating to partition local subcluster number.
				Bit twiddling would be more compact if there is time to implement.
			Num. subclusters will vary with each program instance, array will need to be dynamically allocated.
			Num. subclusters will at least be certain by the time stitching starts.
